## 内存管理

Linux 通过 **内存管理系统** 管理内存，除了各种进程以外，内核本身也需要内存。

### 1. 内存相关的统计信息

使用 `free` 命令，得到：

![](https://pic.imgdb.cn/item/65dc3b459f345e8d03ed0cb1.jpg)

* `total ` ： 系统搭载的物理内存总量 ( 约 `7.9GB` )。	
* `free`：表面上可用内存量 ( 约 `7.0GB` )。
* `buff/cache` : 缓冲区缓存与页面缓存 ( 约`342 MB` )。
* `available` ：实际可用内存量。本字段的值为 `free` 字段的值加上内存不足，内核可释放的内存量。“可释放的内存” 指缓冲区缓存与页面缓存中的大部分内存，以及内核除此以外的用于其他地方的部分内存 ( 约 `7.1GB` )。

大致为：

![](https://pic.imgdb.cn/item/65dc40d99f345e8d03fb2659.jpg)

同时 `sar -r 1` 可以采集一些内存的相关信息：

![](https://pic.imgdb.cn/item/65dc6ae79f345e8d0364e561.jpg)

| free 命令的字段 | sar -r 命令的字段    |
| --------------- | -------------------- |
| total           | 没有                 |
| free            | kbmemfree            |
| buff/cache      | kbbuffers + kbcached |
| available       | 没有                 |
|                 |                      |

### 2. 内存不足

随着内存使用量增加，可用内存变得越来越少，首先内核会将可释放的内存释放出来：

![](https://pic.imgdb.cn/item/65dc722b9f345e8d0378845e.jpg)

如果内存使用量继续增加，系统就会陷入做什么都缺乏足够的内存，以至于陷入 **内存不足**（Out of memory）。此时内存管理系统会运行 **OOM killer** 的功能，它会选出合适的进程，并将其 `kill` 掉，以释放更多内存。

个人电脑出现 OOM 问题不大，但是如果在商用的系统服务器上出现，则完全不知道 OOM killer 杀掉了哪个程序，因此也有将服务器 `sysctl` 的 `vm.panic_on_oom` 参数从默认的 `0` 调整为 `1`，这样使得发生 OOM 时候强制系统关机。

### 3. 简单的内存分配

本小节，暂时先不谈虚拟内存部分，只讨论简单的分配制度，内核为进程分配内存的时机大致分为以下两种：

* 在创建进程时 (`fork，fork and exec`)
* 在创建完进程后，动态分配内存时

进程被创建后，如果需要更多内存，进程向内核发出用于获取内存的系统调用，提出分配内存的请求。内核收到请求后，会按照请求量在可用内存中分出相应大小的内存，并将这部分内存的起始地址返回给提出请求的进程。·

但是这种模式会引起下列问题：

* 内存碎片化。
* 访问用于其它用途的内存区域。
* 难以执行多任务。

#### 3.1 内存碎片化

例如：

![](https://pic.imgdb.cn/item/65dc837b9f345e8d03ab7175.jpg)

假设上述地址单位为 KB。上述现象(内存碎片化)会导致本来还剩 `300KB` 的内存，却分出 `300KB` 的内存

#### 3.2 访问用于其它用途的内存

上述模式中，进程均可以通过内存地址来访问内核和其它进程所使用的内存，因此容易存在数据被泄露或者损毁的风险，如果内核的数据被损毁，系统将无法运行。

#### 3.3 难以执行多任务

之前我们了解到可执行程序存在一个固定的代码块，数据块的存储起始地址，那么如果计算机按照之前我们提及的模式管理内存，如果同时运行两个相同程序，按道理这两个程序都需要在同一块，这就意味着只能运行一个，然而事实上我们是可以运行多个程序的，另一种放置方式如图所示：

![](https://pic.imgdb.cn/item/65dc85db9f345e8d03b30acc.jpg)

但是此时第 **2** 个程序由于代码和数据指向的内存地址与预期不同而无法执行。

> 引入虚拟内存机制可以解决如上问题。
